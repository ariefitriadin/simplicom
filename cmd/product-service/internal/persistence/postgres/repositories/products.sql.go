// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: products.sql

package pgrepo

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteProductStock = `-- name: DeleteProductStock :exec
DELETE FROM product_stocks
WHERE product_id = $1 AND warehouse_id = $2
`

type DeleteProductStockParams struct {
	ProductID   int32 `json:"productId"`
	WarehouseID int32 `json:"warehouseId"`
}

func (q *Queries) DeleteProductStock(ctx context.Context, arg DeleteProductStockParams) error {
	_, err := q.db.Exec(ctx, deleteProductStock, arg.ProductID, arg.WarehouseID)
	return err
}

const getAllProductsWithStock = `-- name: GetAllProductsWithStock :many
SELECT 
    p.id,
    p.name,
    p.description,
    p.price,
    p.createdAt,
    p.updatedAt,
    ps.warehouse_id,
    ps.stock_level
FROM 
    products p
LEFT JOIN 
    product_stocks ps ON p.id = ps.product_id
LIMIT $1 OFFSET $2
`

type GetAllProductsWithStockParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetAllProductsWithStockRow struct {
	ID          int32            `json:"id"`
	Name        string           `json:"name"`
	Description pgtype.Text      `json:"description"`
	Price       pgtype.Numeric   `json:"price"`
	Createdat   pgtype.Timestamp `json:"createdat"`
	Updatedat   pgtype.Timestamp `json:"updatedat"`
	WarehouseID pgtype.Int4      `json:"warehouseId"`
	StockLevel  pgtype.Int4      `json:"stockLevel"`
}

func (q *Queries) GetAllProductsWithStock(ctx context.Context, arg GetAllProductsWithStockParams) ([]GetAllProductsWithStockRow, error) {
	rows, err := q.db.Query(ctx, getAllProductsWithStock, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllProductsWithStockRow{}
	for rows.Next() {
		var i GetAllProductsWithStockRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Price,
			&i.Createdat,
			&i.Updatedat,
			&i.WarehouseID,
			&i.StockLevel,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductByID = `-- name: GetProductByID :one
SELECT 
    p.id,
    p.name,
    p.description,
    p.price,
    ps.warehouse_id,
    ps.stock_level
FROM 
    products p
LEFT JOIN 
    product_stocks ps ON p.id = ps.product_id
WHERE 
    p.id = $1
`

type GetProductByIDRow struct {
	ID          int32          `json:"id"`
	Name        string         `json:"name"`
	Description pgtype.Text    `json:"description"`
	Price       pgtype.Numeric `json:"price"`
	WarehouseID pgtype.Int4    `json:"warehouseId"`
	StockLevel  pgtype.Int4    `json:"stockLevel"`
}

func (q *Queries) GetProductByID(ctx context.Context, id int32) (GetProductByIDRow, error) {
	row := q.db.QueryRow(ctx, getProductByID, id)
	var i GetProductByIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Price,
		&i.WarehouseID,
		&i.StockLevel,
	)
	return i, err
}

const insertProduct = `-- name: InsertProduct :one
INSERT INTO products (name, description, price)
VALUES ($1, $2, $3)
RETURNING id, name, description, price, createdAt, updatedAt
`

type InsertProductParams struct {
	Name        string         `json:"name"`
	Description pgtype.Text    `json:"description"`
	Price       pgtype.Numeric `json:"price"`
}

type InsertProductRow struct {
	ID          int32            `json:"id"`
	Name        string           `json:"name"`
	Description pgtype.Text      `json:"description"`
	Price       pgtype.Numeric   `json:"price"`
	Createdat   pgtype.Timestamp `json:"createdat"`
	Updatedat   pgtype.Timestamp `json:"updatedat"`
}

func (q *Queries) InsertProduct(ctx context.Context, arg InsertProductParams) (InsertProductRow, error) {
	row := q.db.QueryRow(ctx, insertProduct, arg.Name, arg.Description, arg.Price)
	var i InsertProductRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Price,
		&i.Createdat,
		&i.Updatedat,
	)
	return i, err
}

const insertProductStock = `-- name: InsertProductStock :one
INSERT INTO product_stocks (product_id, warehouse_id, stock_level)
VALUES ($1, $2, $3)
RETURNING product_id, warehouse_id, stock_level
`

type InsertProductStockParams struct {
	ProductID   int32       `json:"productId"`
	WarehouseID int32       `json:"warehouseId"`
	StockLevel  pgtype.Int4 `json:"stockLevel"`
}

type InsertProductStockRow struct {
	ProductID   int32       `json:"productId"`
	WarehouseID int32       `json:"warehouseId"`
	StockLevel  pgtype.Int4 `json:"stockLevel"`
}

func (q *Queries) InsertProductStock(ctx context.Context, arg InsertProductStockParams) (InsertProductStockRow, error) {
	row := q.db.QueryRow(ctx, insertProductStock, arg.ProductID, arg.WarehouseID, arg.StockLevel)
	var i InsertProductStockRow
	err := row.Scan(&i.ProductID, &i.WarehouseID, &i.StockLevel)
	return i, err
}

const updateProductStock = `-- name: UpdateProductStock :exec
UPDATE product_stocks
SET stock_level = $1, warehouse_id = $2, updatedAt = NOW()
WHERE product_id = $3 AND warehouse_id = $4
`

type UpdateProductStockParams struct {
	StockLevel    pgtype.Int4 `json:"stockLevel"`
	WarehouseID   int32       `json:"warehouseId"`
	ProductID     int32       `json:"productId"`
	WarehouseID_2 int32       `json:"warehouseId2"`
}

func (q *Queries) UpdateProductStock(ctx context.Context, arg UpdateProductStockParams) error {
	_, err := q.db.Exec(ctx, updateProductStock,
		arg.StockLevel,
		arg.WarehouseID,
		arg.ProductID,
		arg.WarehouseID_2,
	)
	return err
}
