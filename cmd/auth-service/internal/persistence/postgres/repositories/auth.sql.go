// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: auth.sql

package pgrepo

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createClient = `-- name: CreateClient :exec
INSERT INTO oauth2_clients (client_id, client_secret, domain, scope, redirect_url)
VALUES ($1, $2, $3, $4, $5)
`

type CreateClientParams struct {
	ClientID     uuid.UUID `json:"clientId"`
	ClientSecret uuid.UUID `json:"clientSecret"`
	Domain       string    `json:"domain"`
	Scope        []string  `json:"scope"`
	RedirectUrl  string    `json:"redirectUrl"`
}

func (q *Queries) CreateClient(ctx context.Context, arg CreateClientParams) error {
	_, err := q.db.Exec(ctx, createClient,
		arg.ClientID,
		arg.ClientSecret,
		arg.Domain,
		arg.Scope,
		arg.RedirectUrl,
	)
	return err
}

const createToken = `-- name: CreateToken :exec
INSERT INTO oauth2_tokens (access_token, refresh_token, expires_at, client_id, user_id)
VALUES ($1, $2, $3, $4, $5)
`

type CreateTokenParams struct {
	AccessToken  string           `json:"accessToken"`
	RefreshToken pgtype.Text      `json:"refreshToken"`
	ExpiresAt    pgtype.Timestamp `json:"expiresAt"`
	ClientID     uuid.UUID        `json:"clientId"`
	UserID       uuid.UUID        `json:"userId"`
}

func (q *Queries) CreateToken(ctx context.Context, arg CreateTokenParams) error {
	_, err := q.db.Exec(ctx, createToken,
		arg.AccessToken,
		arg.RefreshToken,
		arg.ExpiresAt,
		arg.ClientID,
		arg.UserID,
	)
	return err
}

const deleteClientByID = `-- name: DeleteClientByID :exec
DELETE FROM oauth2_clients
WHERE client_id = $1
`

func (q *Queries) DeleteClientByID(ctx context.Context, clientID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteClientByID, clientID)
	return err
}

const deleteTokenByAccess = `-- name: DeleteTokenByAccess :exec
DELETE FROM oauth2_tokens
WHERE access_token = $1
`

func (q *Queries) DeleteTokenByAccess(ctx context.Context, accessToken string) error {
	_, err := q.db.Exec(ctx, deleteTokenByAccess, accessToken)
	return err
}

const deleteTokenByRefresh = `-- name: DeleteTokenByRefresh :exec
DELETE FROM oauth2_tokens
WHERE refresh_token = $1
`

func (q *Queries) DeleteTokenByRefresh(ctx context.Context, refreshToken pgtype.Text) error {
	_, err := q.db.Exec(ctx, deleteTokenByRefresh, refreshToken)
	return err
}

const getClientByID = `-- name: GetClientByID :one
SELECT id, client_id, client_secret, domain, scope, redirect_url
FROM oauth2_clients
WHERE client_id = $1
`

type GetClientByIDRow struct {
	ID           int32     `json:"id"`
	ClientID     uuid.UUID `json:"clientId"`
	ClientSecret uuid.UUID `json:"clientSecret"`
	Domain       string    `json:"domain"`
	Scope        []string  `json:"scope"`
	RedirectUrl  string    `json:"redirectUrl"`
}

func (q *Queries) GetClientByID(ctx context.Context, clientID uuid.UUID) (GetClientByIDRow, error) {
	row := q.db.QueryRow(ctx, getClientByID, clientID)
	var i GetClientByIDRow
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.ClientSecret,
		&i.Domain,
		&i.Scope,
		&i.RedirectUrl,
	)
	return i, err
}

const getScopeByClientID = `-- name: GetScopeByClientID :one
SELECT scope
FROM oauth2_clients
WHERE client_id = $1
`

func (q *Queries) GetScopeByClientID(ctx context.Context, clientID uuid.UUID) ([]string, error) {
	row := q.db.QueryRow(ctx, getScopeByClientID, clientID)
	var scope []string
	err := row.Scan(&scope)
	return scope, err
}

const getTokenByAccess = `-- name: GetTokenByAccess :one
SELECT id, access_token, refresh_token, expires_at, client_id, user_id
FROM oauth2_tokens
WHERE access_token = $1
`

func (q *Queries) GetTokenByAccess(ctx context.Context, accessToken string) (Oauth2Token, error) {
	row := q.db.QueryRow(ctx, getTokenByAccess, accessToken)
	var i Oauth2Token
	err := row.Scan(
		&i.ID,
		&i.AccessToken,
		&i.RefreshToken,
		&i.ExpiresAt,
		&i.ClientID,
		&i.UserID,
	)
	return i, err
}

const getTokenByRefresh = `-- name: GetTokenByRefresh :one
SELECT id, access_token, refresh_token, expires_at, client_id, user_id
FROM oauth2_tokens
WHERE refresh_token = $1
`

func (q *Queries) GetTokenByRefresh(ctx context.Context, refreshToken pgtype.Text) (Oauth2Token, error) {
	row := q.db.QueryRow(ctx, getTokenByRefresh, refreshToken)
	var i Oauth2Token
	err := row.Scan(
		&i.ID,
		&i.AccessToken,
		&i.RefreshToken,
		&i.ExpiresAt,
		&i.ClientID,
		&i.UserID,
	)
	return i, err
}
